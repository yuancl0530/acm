# 求逆序数的方法

## 1.归并排序

```
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <queue>
#include <stack>
#include <map>
#include <vector>
#include <list>
#include <set>
using namespace std;
#define CL(a) memset(a,0,sizeof(a));
#define INF 0x7fffffff
const int maxn = 1e6;
int L[maxn];
int R[maxn];
int a[maxn];
int ans; //记录结果
void _merge(int *a,int l,int t,int r)
{
	int n1 = t - l;
	int n2 = r - t;
	for (int i = 0;i < n1;i++)
		L[i] = a[l+i];
	for (int i = 0;i < n2;i++)
		R[i] = a[t+i];
	L[n1] = INF;
	R[n2] = INF;
	int k = l,i = 0,j = 0;
	while (k < r){
		if (L[i]>R[j]){
			a[k++] = R[j++];
			ans += n1-i;//R[j]与a[i]~a[n1-1]是逆序对
		}
		else{ 
			a[k++] = L[i++];
		}
	}
}
void merge(int *a,int l,int r)
{
	if (l+1 < r){
		merge(a,l,(l+r)/2);
		merge(a,(l+r)/2,r);
		_merge(a,l,(l+r)/2,r);
	}
}
int a[maxn];
int main()
{
	ans = 0;
	int n;
	scanf("%d",&n);
	for (int i = 0;i < n;i++)
		scanf("%d",&a[i]);
	merge(a,0,n);
	printf("%d\n",ans);
	return 0;
}

```

## 2.树状数组
```
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <queue>
#include <stack>
#include <map>
#include <vector>
#include <list>
#include <set>
using namespace std;
#define CL(a) memset(a,0,sizeof(a));
#define INF 0x7fffffff
const int maxn = 1e6+10;
int sum[maxn];
int n;
struct Node
{
	int index;
	int val;
}a[maxn];
bool cmp(Node a,Node b){return a.val < b.val;}
int lowbit(int x){return x&-x;}
int Sum(int pos)
{
	int ret = 0;
	while (pos > 0){
		ret += sum[pos];
		pos -= lowbit(pos);
	}
	return ret;
}
void update(int pos,int d)
{
	while (pos <= n){
		sum[pos] += d;
		pos += lowbit(pos);
	}

}
int main()
{
	int ans = 0;
	scanf("%d",&n);
	CL(a);
	CL(sum);
	for (int i = 1;i <= n;i++){
		scanf("%d",&a[i].val);
		a[i].index=i;
	}
	sort(a+1,a+1+n,cmp);
	for (int i = 1;i <= n;i++){
		update(a[i].index,1);
		ans += i - Sum(a[i].index);//a[i]与前i位逆序对的个数
	}
	cout<<ans<<endl;
	return 0;
}

```

