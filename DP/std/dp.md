# 动态规划

## 动态规划的基本思想
将一个问题分解为子问题递归求解，且将中间结果保存以避免重复计算。通常用来求最优解，且最优解的局部也是最优的。求解过程产生多个决策序列，下一步总是依赖上一步的结果，自底向上的求解。
动态规划算法可分解成从先到后的4个步骤：

1. 描述一个最优解的结构，寻找子问题，对问题进行划分。
2. 定义状态。往往将和子问题相关的各个变量的一组取值定义为一个状态。某个状态的值就是这个子问题的解（若有k个变量，一般用K维的数组存储各个状态下的解，并可根据这个数组记录打印求解过程）。
3. 找出状态转移方程。一般是从一个状态到另一个状态时变量值改变。 
4. 以“自底向上”的方式计算最优解的值。 
5. 从已计算的信息中构建出最优解的路径。(最优解是问题达到最优值的一组解)

其中步骤1~4是动态规划求解问题的基础，如果题目只要求最优解的值，则步骤5可以省略。

***

# 最大连续子段和  
N个整数组成的序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续子段和的最大值。当所给的整数均为负数时和为0。  

1.**定义状态:**
>sum[i]表示以第i位为结尾的最大子段和,ans为整个序列的最大字段和.  

2.**状态转移**:  
>`sum[i] = max{sum[i-1],0}+a[i]`  
`ans = max{sum[1],sum[2].....sum[n]}`

sum[i]只与sum[i-1]有关,我们可以不用数组来记录,只用sum记录以当前元素结尾的最大子段和,每次更新sum即可.

3.**自底向上求解:**  
>
```
    ans= sum = 0;
    for (i = 1;i <= n;i++){
		sum = max(sum,0)+a[i];
		ans = max(sum,ans);
	}

```
***

# 最长递增子序列  
子串&子序列：  
子串：指给定字符串中选取的某一连续的段  
子序列：可以不连续，但是要保证原字符串的顺序  
## 方法一(时间复杂度O(n^2))
**1.定义状态:**
>dp[i]表示以第i位为结尾的最长递增子序列.  

**2.状态转移:**  
我们可以在所有以`a[j](a[j]<a[i])`为结尾的子序列末尾加上a[i],构成以a[i]为结尾的最长递增子序列,长度为以`a[j]`为结尾的最长递增子序列的长度+1.  

>`dp[i]=max{dp[j]+1}(a[j]<a[i])`  

**3.自底向上求解**  
```
    for (int i = 1;i <= n;i++) dp[i] = 1;
    for (int i = 1;i <= n;i++){
	   int j = i-1;
	   while (j > 0){
			if (a[i] > a[j]){
				dp[i] = max(dp[i],dp[j]+1);
			}
			j--;
		}
	}

```

## 方法二(时间复杂度O(nlogn))


**1.定义状态:**
>f[j]表示长度为j的子序列的最后一项的最小值(规定当不存在长度为j的递增子序列时长度f[j]=INF)  

**2.状态转移:**  

>在处理到到第i位时,  
如果`a[i] > f[j],那么a[i]可以做长度为j+1位的组序列的的最后一项,  
f[j+1]=min{f[j+1],a[i]}`  
f[1]<f[2]<f[3]...<f[j]<a[i]<f[i+1]  
`j = max{j|f[j]>a[i]}`**(二分查找)**  
`f[j+1] = a[i]`  
`ans = max(ans,j+1)`

**二分的时间复杂度为O(logn),总的时间复杂度O(nlogn)**

**3.自底向上求解:**  
(略)

***
## 最长公共子序列问题(LCS)


**1.定义状态:**`dp[i][j]`表示a串的前i位，和b串的前j位的最长公共子序列长度。

**2.状态转移：**

>(1)当`a[i] == b[j]`时,`dp[i][j] = dp[i-1][j-1] + 1`  
(2)当`a[i] != b[j]`时，`dp[i][j] = max{dp[i-1][j],dp[i][j-1]}`  


**3.自底向上求解：**

```
    for (int i = 0;i <= lena;i++)
        dp[i][0] = 0;
    for (int i = 0;i <= lenb;i++) 
        dp[0][i] = 0;
    for (int i= 1;i <= lena;i++){
        for (int j = 1;j <= lenb;j++){
            if (a[i] == b[j]){
                dpi][j] = dp[i-1][j-1] + 1;
            }
            else{
                dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            }
        }
    }
```

## 最长公共子串

**1.定义状态:**`dp[i][j]`表示以a串第i位和b串的第j位结尾的最长公共子串长度。

**2.状态转移：**

>(1)当`a[i] == b[j]`时,`dp[i][j] = dp[i-1][j-1] + 1`  
(2)当`a[i] != b[j]`时，`dp[i][j] = 0`  


**3.自底向上求解：**

```
    for (int i = 0;i <= lena;i++)
        dp[i][0] = 0;
    for (int i = 0;i <= lenb;i++) 
        dp[0][i] = 0;
    for(int i= 1;i <= lena;i++){
        for (int j = 1;j <= lenb;j++){
            if (a[i] == b[j]){
                dp[i][j] = dp + 1;
            }
            else{
                dp[i][j] = 0;
            }
        }
    }
```





















