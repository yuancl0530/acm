# 动态规划

## 动态规划的基本思想
将一个问题分解为子问题递归求解，且将中间结果保存以避免重复计算。通常用来求最优解，且最优解的局部也是最优的。求解过程产生多个决策序列，下一步总是依赖上一步的结果，自底向上的求解。
动态规划算法可分解成从先到后的4个步骤：

1. 描述一个最优解的结构，寻找子问题，对问题进行划分。
2. 定义状态。往往将和子问题相关的各个变量的一组取值定义为一个状态。某个状态的值就是这个子问题的解（若有k个变量，一般用K维的数组存储各个状态下的解，并可根据这个数组记录打印求解过程）。
3. 找出状态转移方程。一般是从一个状态到另一个状态时变量值改变。 
4. 以“自底向上”的方式计算最优解的值。 
5. 从已计算的信息中构建出最优解的路径。(最优解是问题达到最优值的一组解)

其中步骤1~4是动态规划求解问题的基础，如果题目只要求最优解的值，则步骤5可以省略。

***

# 最大连续子段和  
N个整数组成的序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续子段和的最大值。当所给的整数均为负数时和为0。  

1.**定义状态:**
>sum[i]表示以第i位为结尾的最大子段和,ans为整个序列的最大字段和.  

2.**状态转移**:  
>`sum[i] = max{sum[i-1]+a[i],a[i]}`  
`ans = max{sum[1],sum[2].....sum[n]}`

sum[i]只与sum[i-1]有关,我们可以不用数组来记录,只用sum记录以当前元素结尾的最大子段和,每次更新sum即可.

3.**自底向上求解:**  
>
```
    ans= sum = 0;
    for (i = 1;i <= n;i++){
		sum = max(sum,0)+a[i];
		ans = max(sum,ans);
	}

```
***

# 最长递增子序列  
子串&子序列：  
子串：指给定字符串中选取的某一连续的段  
子序列：可以不连续，但是要保证原字符串的顺序  
## 方法一(时间复杂度O(n^2))
**1.定义状态:**
>dp[i]表示以第i位为结尾的最长递增子序列.  

**2.状态转移:**  
我们可以在所有以`a[j](a[j]<a[i])`为结尾的子序列末尾加上a[i],构成以a[i]为结尾的最长递增子序列,长度为以`a[j]`为结尾的最长递增子序列的长度+1.  

>`dp[i]=max{dp[j]+1}(a[j]<a[i])`  

**3.自底向上求解**  
```
    for (int i = 1;i <= n;i++){
	   int j = i-1;
		while (j > 0){
			if (a[i] > a[j]){
				dp[i] = max(dp[i],dp[j]+1);
			}
			j--;
		}
	}

```

## 方法二(时间复杂度O(nlogn))


**1.定义状态:**
>dp[i][j]表示处理到第[i]位时,长度为j的子序列的最后一项的最小值  

**2.状态转移:**  

>在求dp[i][j]时,
如果`a[i] > dp[i-1][j-1],dp[i][j]=min{a[i],dp[i-1][j]}`(j<=i)  
否则,`dp[i][j]=dp[i-1][j].`(j<=i)  
通过观察我们发现,每次更新的列j满足`dp[i-1][j-1]<a[i]<dp[i-1][j]`,我们每次最多更新一个值,在这里我们也没有必要用二维数组,  
用f[i]表示长度为i的递增子序列的最后一项的最小值,  
`j = min{j|f[j]>a[i]}`**(二分查找)**  
`f[j+1] = a[i]`

**二分的时间复杂度为O(logn),总的时间复杂度O(nlogn)**

**3.自底向上求解:**  
(略)

***




















